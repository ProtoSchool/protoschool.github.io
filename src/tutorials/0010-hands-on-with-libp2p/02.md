---
    title: "Peer IDs"
    type: "multiple-choice" # can be "text", "code", "file-upload" or "multiple-choice"
---

One of the most fundamental questions when building a system with many participants is how to keep track of them all.

The answer generally involves some sort of identifier or ID, a number that uniquely identifies a single "thing" in the system. 
For example, Mark Zuckerberg has the Facebook user ID `4`, and each new Facebook user is issued the next ID in the sequence.

In a centralized service like Facebook, one database can be in charge of tracking all user IDs, which is how the service knows what number to hand out next. 
Just take the ID of the most recently added user, increase it by one, and you're all set.

But what if we don't have a centralized "ID service"? Can we still uniquely identify the users in our system?

One way would be to just have the users make up their own IDs, so they don't have to ask a service for one. 
This actually works really well if you have a large enough "number space" for the range of possible IDs.
For example, if you encode your IDs using 256 bits, you can have about as many unique IDs as the estimated number of atoms in the observable universe. 
This is great, because it makes it unlikely that two users will randomly choose the same ID.

The problem of course is that any user can choose any ID, even one that's already been used by someone else. 
This means that it would be easy for any user to impersonate someone else, just by using the same ID.
What we need is a way for users to independently "claim" an ID in a way that can easily be verified by others, without requiring a central service for coordination.

It turns out that [public key cryptography][pk-explainer] gives us just what we need. Instead of a single random number, each participant generates a **private key**, which is just a special number that they keep secret and never reveal to anyone else on the network. The private key has an associated **public key**, which is safe to share with everyone. Since the public key can be easily shared, we can either use it as an ID directly, or we can derive an ID from the key using a hash function, so that the same key will always result in the same ID. 

Now when two peers connect to each other, they can exchange IDs and public keys. Each peer then uses their own private key to digitally "sign" some piece of data, which proves that they have the private key. Since only the creator of the ID should know the private key, we can trust that the ID belongs to the peer that created it.

As you may have guessed, this is exactly what libp2p does.

In libp2p, each peer has a unique **Peer ID** which has a relationship to the peer's public key that can't be forged. In the case of small keys used by elliptic curve algorithms like [ed25519][ed25519], the Peer ID contains the key itself. Larger keys like those required by the [RSA algorithm][rsa-explainer] are fed into a [hash function][hash-explainer], and the Peer ID contains the hash output.

Here's what a libp2p Peer ID looks like:

```
bafzbeigweq4zr4x4ky2dvv7nanbkw6egutvrrvzw6g3h2rftp7gidyhtt4
```

You might also see Peer IDs that look like this:

```
QmckZzdVd72h9QUFuJJpQqhsZqGLwjhh81qSvZ9BhB2FQi
```

If you've ever used [IPFS](https://ipfs.io), those strings of gibberish might look familiar! Peer IDs in libp2p are also [CID][docs-cid]s, or Content Identifiers, which are used in IPFS to locate content on the network, among other things. When used as a Peer ID, the content that a CID identifies is the public key of the libp2p peer.

The two examples above look a little different because they're using different versions of the CID standard. The one that starts with `bafz` is a newer version 1 CID, while the ID beginning with `Qm` is an older, version 0 CID. If you want to learn all about CIDs, check out the [Anatomy of a CID tutorial][cid-tutorial] here on ProtoSchool!


[pk-explainer]: https://simple.wikipedia.org/wiki/Public-key_cryptography
[ed25519]: https://ed25519.cr.yp.to/
[rsa-explainer]: https://en.wikipedia.org/wiki/RSA_(cryptosystem)
[hash-explainer]: https://simple.wikipedia.org/wiki/Cryptographic_hash_function
[docs-cid]: https://docs.ipfs.io/concepts/content-addressing
[cid-tutorial]: https://proto.school/anatomy-of-a-cid